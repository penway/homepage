---
title: 11 分糖果
subtitle: 

# Summary for listings and search engines
summary: 算法，递归

# Link this post with a project
projects: [Algorithm]

# Date published
date: "2021-09-16T00:00:00Z"

# Date updated
lastmod: "2021-09-16T00:00:00Z"

# Is this an unpublished draft?
draft: false

# Show this page in the Featured widget?
featured: false

# Featured image
# Place an image named `featured.jpg/png` in this page's folder and customize its options here.
image:
  caption: 'Image credit: [**Unsplash**](./featured.jpg)'
  focal_point: ""
  placement: 2
  preview_only: false

authors:
- penway

tags:
- 算法

categories:
- 算法
---

### Description

老师有一些糖果想要分出去，一次可以分1个糖果，也可以分2个糖果。求该老师分n个糖果总共有多少种分法。

答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。

### Input

输入非负整数n

### Output

输出正整数即方法数



我大概一想这题似乎有点简单，就写了个非常优雅的递归程序：

```c++
int handout(int candy) {
	if (candy <= 1)
        return 1;
    
	return handout(candy - 1) + handout(candy - 2);
}

int main() {
	int candy;
	cin >> candy;
	int ans = handout(candy) % 1000000007;
	cout << ans;
}
```

结果TLE，直接白给，然后我自己一试，输入100根本算不出来，果然是我的问题。



我一搜，有个东西叫递归记忆法，仔细一想，越小的数字越容易重复使用，所以记住算过的结果，让每种handout[candy]都只算一次，那速度就很快了，果不其然，上代码：

```
int memory[1000] = { 1, 1 };

int handout(int candy) {
	
	if (memory[candy] != 0) {
		return memory[candy];
	}

	memory[candy] = handout(candy - 1) % 1000000007 + handout(candy - 2) % 1000000007;
	return memory[candy];
}

int main() {
	
	int candy;
	cin >> candy;

	int ans = handout(candy) % 1000000007;

	cout << ans;
}
```



### 关于1000000007

本来以为只是老师的判断器有问题，需要一个小于int32的数字，结果我写完没有在递归中加入取模的程序之后，发现输入100的结果是负数，才想起来原来是自己溢出了...这个就是避免溢出而来的。



### 性能提升

从递归到递归记忆法，大概是我第一个空间换时间的优化了。本来想对性能做个量化对比的，但是记忆法算handout[100000000]一亿只用了8秒，而原来的方法连100都算不出来，没啥好比的了。

说起来，新方法的效率是O(n)，而且如果要算很多个的话效率更加恐怖。而老方法嘛...我不会算，但是我用python可视化了哈哈，似乎比n^2还要恐怖...

![Figure_1](.\Figure_1.png)




## License

Copyright 2021 王鹏维