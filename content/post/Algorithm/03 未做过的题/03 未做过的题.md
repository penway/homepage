---
title: 【算法】03 未做过的题
subtitle: 

# Summary for listings and search engines
summary: 算法，蛮力法

# Link this post with a project
projects: [Algorithm]

# Date published
date: "2021-09-22T00:00:00Z"

# Date updated
lastmod: "2021-09-22T00:00:00Z"

# Is this an unpublished draft?
draft: false

# Show this page in the Featured widget?
featured: false

# Featured image
# Place an image named `featured.jpg/png` in this page's folder and customize its options here.
image:
  caption: 'Image credit: [**Unsplash**](./featured.jpg)'
  focal_point: ""
  placement: 2
  preview_only: false

authors:
- penway

tags:
- 算法

categories:
- 算法
---

### Description

现在某个题库中有M道题,题号分别是1，2，3......M，有N个学生去做，每个人都做了一部分，求这N个学生都未做过的题目数量。

每个学生做的第一道题可能不同，但每个学生做过的题目序号是连续的，并且不同学生做过的题可能重叠。

### Input

输入包括多组数据，第一行有两个数分别是，题目总数M(0<M<1000)，学生总数N;

接下来的N行，每行包含两个不同的整数，用空格分隔开，

表示每个学生做过的题目起始位置和结束位置（这两个位置的题都被做过）。

### Output

输出包括一行，这一行只包含一个整数，表示这N个学生都未做过的题目数量。



### 蛮力法

题目说了题目总数不超过1000，那么一个数组全部标定就解决问题了，不需要整计算重叠的高端操作。

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
	
	int proNo, stuNo;
	cin >> proNo >> stuNo;

	vector<bool> problems = vector<bool>();
	for (int i = 0; i < proNo; ++i) {

		problems.push_back(false);
	}

	int start, end;
	for (int i = 0; i < stuNo; ++i) {

		cin >> start >> end;
		for (int j = start; j <= end; ++j) {
			problems[j] = true;
		}
	}

	int count = 0;
	for (int i = 0; i < proNo; ++i) {

		if (problems[i] == false) {
			++count;
		}
	}

	cout << count;
}
```




## License

Copyright 2021 王鹏维